name: Clean news.json via Readability

permissions:
  contents: write

on:
  workflow_dispatch: {}          # avvio manuale
  push:
    paths:
      - news.json                # quando news.json cambia
  schedule:
    - cron: '0 1 * * *'          # ogni notte 01:00 UTC

jobs:
  clean:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: true

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name: Install deps
        run: npm install jsdom @mozilla/readability he html-to-text

      - name: Extract & clean article bodies
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const { JSDOM } = require('jsdom');
          const { Readability } = require('@mozilla/readability');
          const he = require('he');
          const { htmlToText } = require('html-to-text');

          const FILE = 'news.json';
          const MAX_CHARS = 20000;              // evita body enormi in JSON
          const UA = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124 Safari/537.36';

          const sleep = ms => new Promise(r => setTimeout(r, ms));

          async function fetchText(url) {
            for (let i = 0; i < 2; i++) {
              try {
                const res = await fetch(url, { headers: { 'user-agent': UA, 'accept': 'text/html,*/*;q=0.8' } });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const ct = res.headers.get('content-type') || '';
                if (!ct.includes('text/html')) {
                  // alcuni siti servono HTML con content-type strano, proviamo lo stesso
                }
                return await res.text();
              } catch (e) {
                if (i === 1) throw e;
                await sleep(1000);
              }
            }
          }

          function tidyParagraphs(txt) {
            if (!txt) return '';
            // normalizza spazi e paragrafi, conserva struttura
            txt = he.decode(txt).replace(/\u00A0/g, ' ');
            txt = txt.replace(/[ \t]+/g, ' ')
                     .replace(/\r/g, '')
                     .replace(/\n{3,}/g, '\n\n')
                     .trim();
            // rimuovi righe che sono solo CSS residuali (conservativo)
            const cssProp = /^(?:color|margin|padding|font|background|display|position|left|right|top|bottom|border|width|height|max-width|min-width|line-height|text-align|justify-content|align-items|flex|grid|z-index|overflow|opacity|box-shadow|transition|transform|animation|visibility|letter-spacing|word-spacing|white-space|object-fit|pointer-events|filter|stroke|fill)\s*:/i;
            txt = txt.split('\n').filter(line => !cssProp.test(line.trim())).join('\n');
            return txt.slice(0, MAX_CHARS);
          }

          function extractWithReadability(html, baseURL) {
            const dom = new JSDOM(html, { url: baseURL, contentType: 'text/html' });
            const doc = dom.window.document;
            const article = new Readability(doc, {
              keepClasses: false
            }).parse();
            if (!article) return null;
            // preferiamo sempre il testo
            const text = article.textContent || htmlToText(article.content || '', { wordwrap: false, preserveNewlines: true });
            return {
              title: article.title || '',
              text: tidyParagraphs(text)
            };
          }

          function fallbackPlain(html) {
            // fallback robusto: HTML -> testo semplice
            const text = htmlToText(html || '', {
              wordwrap: false,
              preserveNewlines: true,
              selectors: [
                { selector: 'a', options: { ignoreHref: true } },
                { selector: 'img', format: 'skip' },
                { selector: 'style', format: 'skip' },
                { selector: 'script', format: 'skip' },
                { selector: 'noscript', format: 'skip' },
                { selector: 'template', format: 'skip' },
                { selector: 'iframe', format: 'skip' }
              ]
            });
            return tidyParagraphs(text);
          }

          function getUrlFromItem(item) {
            // prova varie chiavi comuni
            const candidates = [item.url, item.link, item.id, item.guid, item.permalink];
            const url = (candidates.find(u => typeof u === 'string' && /^https?:\/\//i.test(u)) || '').trim();
            return url;
          }

          const raw = fs.readFileSync(FILE, 'utf8');
          const data = JSON.parse(raw);

          const touchItem = async (item) => {
            if (!item || typeof item !== 'object') return false;

            const url = getUrlFromItem(item);
            if (!url) return false;

            // se body giÃ  pulito (sembra testo e non contiene tag evidenti), salta
            if (typeof item.body === 'string' && !/[<>]{1}|{[^}]+}/.test(item.body) && item.body.length > 80) {
              return false;
            }

            try {
              const html = await fetchText(url);
              let cleaned;
              const r = extractWithReadability(html, url);
              if (r && r.text && r.text.length > 120) {
                cleaned = r.text;
                // se manca il titolo della notizia e Readability lo ha trovato, aggiorna
                if ((!item.title || item.title.length < 5) && r.title) item.title = r.title;
              } else {
                cleaned = fallbackPlain(html);
              }
              if (cleaned && cleaned.length > 40) {
                item.body = cleaned;
                return true;
              }
            } catch (e) {
              // fallback extra: ripulisci il body esistente se c'Ã¨
              if (typeof item.body === 'string' && item.body.length) {
                item.body = fallbackPlain(item.body);
                return true;
              }
            }
            return false;
          };

          async function processArray(arr) {
            if (!Array.isArray(arr)) return 0;
            let changed = 0;
            for (const section of arr) {
              if (!section || !Array.isArray(section.items)) continue;
              for (const it of section.items) {
                const ok = await touchItem(it);
                if (ok) changed++;
                // evita martellate: piccola pausa
                await sleep(300);
              }
            }
            return changed;
          }

          (async () => {
            const changedA = await processArray(data.categories);
            const changedB = await processArray(data.categorie);
            const changed = (changedA || 0) + (changedB || 0);

            fs.writeFileSync(FILE, JSON.stringify(data, null, 2), 'utf8');
            console.log(`Pulizia completata. Elementi aggiornati: ${changed}`);
          })();
          NODE

      - name: Commit & push cleaned JSON
        uses: stefanzweifel/git-auto-commit-action@v4
        with:
          commit_message: "ðŸ§½ Readability: extract clean article text into body"
          file_pattern: news.json
